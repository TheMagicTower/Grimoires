#!/usr/bin/env node
/**
 * Grimoires Hooks CLI
 *
 * Command-line interface for executing Grimoires hooks.
 * Designed to be called by Claude Code's hook system.
 *
 * Usage:
 *   grimoires-hooks <event> [options]
 *
 * Events:
 *   pre-tool-use     Execute before a tool is used
 *   post-tool-use    Execute after a tool is used
 *   session-start    Execute when a session starts
 *   session-end      Execute when a session ends
 *   pre-compact      Execute before context compaction
 *   stop             Execute when response ends
 *
 * Options:
 *   --tool <name>      Tool name (Bash, Write, Edit, Read)
 *   --command <cmd>    Command being executed (for Bash)
 *   --path <path>      File path (for Write/Edit/Read)
 *   --exit-code <n>    Exit code (for post-tool-use)
 *   --success <bool>   Whether operation succeeded
 *   --config <path>    Path to hooks.json
 *   --json             Output in JSON format
 *   --quiet            Suppress non-essential output
 *   --help             Show this help message
 *
 * Examples:
 *   grimoires-hooks pre-tool-use --tool Bash --command "git push"
 *   grimoires-hooks post-tool-use --tool Write --path ./src/app.ts --success true
 *   echo '{"tool":"Bash","command":"npm run dev"}' | grimoires-hooks pre-tool-use
 *
 * @version 0.3.0
 */

const path = require('path');

// Resolve paths relative to this script
const RUNTIME_PATH = path.join(__dirname, '..', 'core', 'runtime');

const { HooksBridge, HookEvent, DEFAULT_PATHS } = require(path.join(RUNTIME_PATH, 'bridge'));
const { buildContext } = require(path.join(RUNTIME_PATH, 'context'));

/**
 * Event name mapping
 */
const EVENT_MAP = {
  'pre-tool-use': HookEvent.PRE_TOOL_USE,
  'post-tool-use': HookEvent.POST_TOOL_USE,
  'session-start': HookEvent.SESSION_START,
  'session-end': HookEvent.SESSION_END,
  'pre-compact': HookEvent.PRE_COMPACT,
  'stop': HookEvent.STOP,
  // Also support PascalCase
  'PreToolUse': HookEvent.PRE_TOOL_USE,
  'PostToolUse': HookEvent.POST_TOOL_USE,
  'SessionStart': HookEvent.SESSION_START,
  'SessionEnd': HookEvent.SESSION_END,
  'PreCompact': HookEvent.PRE_COMPACT,
  'Stop': HookEvent.STOP
};

/**
 * Parse command line arguments
 */
function parseArgs(args) {
  const options = {
    event: null,
    tool: null,
    command: null,
    path: null,
    content: null,
    exitCode: null,
    success: null,
    config: null,
    json: false,
    quiet: false,
    help: false
  };

  let i = 0;
  while (i < args.length) {
    const arg = args[i];

    if (arg === '--help' || arg === '-h') {
      options.help = true;
    } else if (arg === '--json') {
      options.json = true;
    } else if (arg === '--quiet' || arg === '-q') {
      options.quiet = true;
    } else if (arg === '--tool' && args[i + 1]) {
      options.tool = args[++i];
    } else if (arg === '--command' && args[i + 1]) {
      options.command = args[++i];
    } else if (arg === '--path' && args[i + 1]) {
      options.path = args[++i];
    } else if (arg === '--content' && args[i + 1]) {
      options.content = args[++i];
    } else if (arg === '--exit-code' && args[i + 1]) {
      options.exitCode = parseInt(args[++i], 10);
    } else if (arg === '--success' && args[i + 1]) {
      options.success = args[++i] === 'true';
    } else if (arg === '--config' && args[i + 1]) {
      options.config = args[++i];
    } else if (!arg.startsWith('-') && !options.event) {
      options.event = arg;
    }

    i++;
  }

  return options;
}

/**
 * Show help message
 */
function showHelp() {
  console.log(`
Grimoires Hooks CLI v0.3.0

Usage: grimoires-hooks <event> [options]

Events:
  pre-tool-use     Execute before a tool is used
  post-tool-use    Execute after a tool is used
  session-start    Execute when a session starts
  session-end      Execute when a session ends
  pre-compact      Execute before context compaction
  stop             Execute when response ends

Options:
  --tool <name>      Tool name (Bash, Write, Edit, Read)
  --command <cmd>    Command being executed (for Bash)
  --path <path>      File path (for Write/Edit/Read)
  --exit-code <n>    Exit code (for post-tool-use)
  --success <bool>   Whether operation succeeded
  --config <path>    Path to hooks.json
  --json             Output in JSON format
  --quiet            Suppress non-essential output
  --help             Show this help message

Examples:
  grimoires-hooks pre-tool-use --tool Bash --command "git push"
  grimoires-hooks post-tool-use --tool Write --path ./src/app.ts
  echo '{"tool":"Bash","command":"npm run dev"}' | grimoires-hooks pre-tool-use

Exit Codes:
  0    All hooks passed (allow)
  1    Hook blocked the operation
  2    Hook requires confirmation
  3    Error during execution
`);
}

/**
 * Format output based on options
 */
function formatOutput(result, options) {
  if (options.json) {
    return JSON.stringify(result, null, 2);
  }

  const lines = [];

  if (result.blocked) {
    lines.push(`BLOCKED: ${result.messages.find(m => m.type === 'block')?.message || 'Operation blocked'}`);
  } else if (result.confirm) {
    lines.push(`CONFIRM: ${result.messages.find(m => m.type === 'confirm')?.message || 'Confirmation required'}`);
  }

  for (const warning of result.warnings) {
    lines.push(`WARNING: ${warning.message}`);
  }

  if (!options.quiet && result.executed.length > 0) {
    const executed = result.executed.filter(e => e.executed);
    if (executed.length > 0) {
      lines.push(`Executed ${executed.length} hook(s)`);
    }
  }

  return lines.join('\n');
}

/**
 * Main function
 */
async function main() {
  const args = process.argv.slice(2);
  const options = parseArgs(args);

  if (options.help) {
    showHelp();
    process.exit(0);
  }

  if (!options.event) {
    console.error('Error: Event type is required');
    console.error('Usage: grimoires-hooks <event> [options]');
    console.error('Run "grimoires-hooks --help" for more information');
    process.exit(3);
  }

  const event = EVENT_MAP[options.event];
  if (!event) {
    console.error(`Error: Unknown event type: ${options.event}`);
    console.error('Valid events: pre-tool-use, post-tool-use, session-start, session-end, pre-compact, stop');
    process.exit(3);
  }

  try {
    // Build context from options and stdin
    const context = await buildContext({
      args: process.argv.slice(2),
      stdin: true
    });

    // Override with explicit options
    if (options.tool) context.tool = options.tool;
    if (options.command) context.command = options.command;
    if (options.path) context.path = options.path;
    if (options.content) context.content = options.content;
    if (options.exitCode !== null) context.exitCode = options.exitCode;
    if (options.success !== null) context.success = options.success;

    // Create bridge and execute
    const bridge = new HooksBridge({
      configPath: options.config,
      silent: options.quiet
    });

    const result = await bridge.executeHooks(event, context);

    // Output result
    const output = formatOutput(result, options);
    if (output) {
      console.log(output);
    }

    // Exit with appropriate code
    if (result.blocked) {
      process.exit(1);
    } else if (result.confirm) {
      process.exit(2);
    } else {
      process.exit(0);
    }

  } catch (error) {
    if (options.json) {
      console.log(JSON.stringify({ error: error.message, status: 'error' }));
    } else {
      console.error(`Error: ${error.message}`);
    }
    process.exit(3);
  }
}

// Run main
main();
